{"version":3,"sources":["client.js"],"names":[],"mappings":";;;;;;;;AAIA;;;;;;;;;IAoBM,a;AAGJ,yBAAY,MAAZ,EAA2B,IAA3B,EAAyC;AAAA;;AACvC,SAAK,MAAL,GAAc,MAAd;AACA,SAAK,IAAL,GAAY,IAAZ;AACD;;;;;2EACW,U,EAA0B,M;;;YAIhC,S,EAgBA,S;;;;;AAnBJ,oCAAS,WAAW,IAAX,IAAiB,IAA1B,EAA+B,uGACyB,UADzB,OAA/B;;AAGI,yB;;AACJ,oBAAI,MAAJ,EAAY;;;;;;;AAOV,yBAAO,IAAP,KAAgB,WAAW,IAAX,GAAkB,OAAO,IAAzC;AACA,yBAAO,CAAP,KAAa,WAAW,IAAX,GAAkB,OAAO,CAAtC;AACA,yBAAO,MAAP,KAAkB,WAAW,MAAX,GAAoB,OAAO,MAA7C;AACA,yBAAO,CAAP,KAAa,WAAW,MAAX,GAAoB,OAAO,CAAxC;;AAEA,8BAAY,OAAO,SAAnB;AACD;;AAEG,yB,GAAkC,U;;;;AAGtC,oBAAM,WAAW,MAAX,IAAmB,IAApB,IAA8B,WAAW,MAAX,IAAqB,EAAxD,EAA6D;AAC3D,8BAAY,WAAW,IAAvB;AACD;;qBAEG,S;;;;;iDACK,IAAI,OAAJ,CAAa,UAAC,OAAD,EAAU,MAAV,EAAqB;AACvC,sBAAM,QAAQ,MAAK,MAAL,CAAY,KAAZ,CAAkB,SAAlB,CAAd;AACA,wBAAM,EAAN,CAAS,KAAT,EAAgB,SAAhB;AACA,wBAAM,EAAN,CAAS,OAAT,EAAkB,iBAAS;AACzB,0BAAK,IAAL;AACA,uDAAiC,KAAjC;AACD,mBAHD;AAIA,wBAAM,EAAN,CAAS,KAAT,EAAgB,UAAC,MAAD,EAAY;AAC1B,0BAAK,IAAL;AACA,4BAAQ,MAAR;AACD,mBAHD;AAID,iBAXM,C;;;iDAaA,IAAI,OAAJ,CAAa,UAAC,OAAD,EAAU,MAAV,EAAqB;AACvC,wBAAK,MAAL,CAAY,KAAZ,CAAkB,SAAlB,EAA6B,UAAC,GAAD,EAAM,MAAN,EAAiB;AAC5C,0BAAK,IAAL;AACA,wBAAI,GAAJ,EAAS;AACP,yDAAiC,GAAjC;AACD,qBAFD,MAEO;AACL,8BAAQ,MAAR;AACD;AACF,mBAPD;AAQD,iBATM,C;;;;;;;;;;;;;;;;;;;;;kBAgBE,a","file":"client.js","sourcesContent":["/*\n * @flow\n */\nimport type {pgQueryConfig} from 'tagged-literals';\nimport {multiAssign, devError} from './util';\n\ntype Result = {\n  command:string,\n  rowCount:number,\n  oid:mixed,\n  rows:Array<mixed>,\n  addRow: (row:mixed) => void\n};\n\ntype queryParams = {\n  V:?mixed[],\n  values:?mixed[],\n  N:?string,\n  name: ?string,\n  rowHandle: ?(row:mixed, result:Result) =>void\n};\n\n// function inside a class must be arrow function!\n// for binding this to the class\nclass ClientWrapper {\n  client: any;\n  done: ()=>any;\n  constructor(client: mixed, done:()=>any) {\n    this.client = client;\n    this.done = done;\n  }\n  async query(sqlCommand:pgQueryConfig, params: ?queryParams ):Promise<Result> {\n    devError(sqlCommand.text==null,'ClientWrapper.query only accept sqlCommand'\n      +`return from SQL tagged template,but the input is [${sqlCommand}]`);\n\n    let rowHandle;\n    if (params) {\n/*    // set N|name => name, V|values => values;\n      params.assign = multiAssign;\n      params.assign('V','values').to(sqlCommand,'values');\n      params.assign('N','name').to(sqlCommand,'name');\n*/\n      // fast set ~ N|name => name, V|values => values;\n      params.name && (sqlCommand.name = params.name);\n      params.N && (sqlCommand.name = params.N);\n      params.values && (sqlCommand.values = params.values);\n      params.V && (sqlCommand.values = params.V);\n\n      rowHandle = params.rowHandle;\n    }\n\n    let pgCommand: pgQueryConfig|string = sqlCommand;\n    // if there is no values in sqlCommand\n    // just set pgCommand passed to pg to string. for fast speed?\n    if ( (sqlCommand.values==null) || (sqlCommand.values == [])) {\n      pgCommand = sqlCommand.text;\n    }\n\n    if (rowHandle) { // use node-postgres 's event system\n      return new Promise( (resolve, reject) => {\n        const query = this.client.query(pgCommand);\n        query.on('row', rowHandle);\n        query.on('error', error => {\n          this.done();\n          reject(`[ClientWrapper.query]: ${error}`);\n        });\n        query.on('end', (result) => {\n          this.done();\n          resolve(result);\n        });\n      });\n    } else { // the node-postgres's directly callback\n      return new Promise( (resolve, reject) => {\n        this.client.query(pgCommand, (err, result) => {\n          this.done();\n          if (err) {\n            reject(`[ClientWrapper.query]: ${err}`);\n          } else {\n            resolve(result);\n          }\n        });\n      });\n    }\n\n  }\n}\n\n\nexport default ClientWrapper;\n"],"sourceRoot":"/home/iamchenxin/project/lang/es7-postgres/src"}